points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
plot(locs[,1],locs[,2])
### instantiate GP(theta)
D = as.matrix(dist(locs, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(N)
### perform thinning
obs = rep(FALSE,N)
for (i in 1:N) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
locObs = locs[obs,]
locThin = locs[!obs,]
plot(locObs[,1],locObs[,2])
points(locThin[,1],locThin[,2],col="red")
### RJMCMC
### insertion probability
b = function(M){
if(M==0){
return(1)
}else{
return(1/2)
}
}
b(0)
b(1)
b(100)
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
K = rpois(1,lambda)
X = matrix(runif(2*K),K,2)
plot(X[,1],X[,2])
### instantiate GP(theta)
D = as.matrix(dist(X, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(K)
### perform thinning
obs = rep(FALSE,K)
for (i in 1:K) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
X_N = X[obs,]
X_M = X[!obs,]
g_N = g[obs,]
g_M = g[!obs,]
plot(X_N[,1],X_N[,2])
points(X_M[,1],X_M[,2],col="red")
### RJMCMC
### insertion probability
b = function(M){
if(M==0){
return(1)
}else{
return(1/2)
}
}
### insertion
### parameters
theta = 2
lambda = 200
### Homogenenous PPP(lambda)
K = rpois(1,lambda)
X = matrix(runif(2*K),K,2)
plot(X[,1],X[,2])
### instantiate GP(theta)
D = as.matrix(dist(X, diag = TRUE))
Sigma = exp(-theta*D)
g = t(chol(Sigma)) %*% rnorm(K)
### perform thinning
obs = rep(FALSE,K)
for (i in 1:K) {
obs[i] = as.logical(rbinom(1,1,pnorm(g[i])))
}
X_N = X[obs,]
X_M = X[!obs,]
g_N = g[obs,]
g_M = g[!obs,]
plot(X_N[,1],X_N[,2])
points(X_M[,1],X_M[,2],col="red")
### RJMCMC
### insertion probability
b = function(M){
if(M==0){
return(1)
}else{
return(1/2)
}
}
install.packages("coda")
libary(coda)
library(coda)
effectiveSize(1:N)
effectiveSize(1:10)
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(10))
effectiveSize(1:10 + rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(100))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
effectiveSize(rnorm(1000))
knitr::opts_chunk$set(echo = TRUE)
rAR1 = function(n,sigma,alpha){
eps = rnorm(n,0,sigma)
x = rep(0,n)
x[1] = eps[1]
for (i in 2:n) {
x[i] = alpha*x[i-1] + eps[i]
}
return(x)
}
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.9))
effectiveSize(rAR1(1000,1,0.9))
effectiveSize(rAR1(1000,1,0.9))
effectiveSize(rAR1(1000,1,0.9))
effectiveSize(rAR1(1000,1,-0.9))
effectiveSize(rAR1(1000,1,-0.9))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.1))
library(coda)
rAR1 = function(n,sigma,alpha){
eps = rnorm(n,0,sigma)
x = rep(0,n)
x[1] = eps[1]
for (i in 2:n) {
x[i] = alpha*x[i-1] + eps[i]
}
return(x)
}
effectiveSize(1:1000)
effectiveSize(rnorm(1000))
effectiveSize(rAR1(1000,1,0.9))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.1))
effectiveSize(rAR1(1000,1,-0.1))
effectiveSize(rAR1(1000,1,-0.5))
effectiveSize(rAR1(1000,1,-0.9))
library(coda)
rAR1 = function(n,sigma,alpha){
eps = rnorm(n,0,sigma)
x = rep(0,n)
x[1] = eps[1]
for (i in 2:n) {
x[i] = alpha*x[i-1] + eps[i]
}
return(x)
}
effectiveSize(1:1000)
effectiveSize(rnorm(1000))
effectiveSize(rAR1(1000,1,0.9))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.1))
effectiveSize(rAR1(1000,1,-0.1))
effectiveSize(rAR1(1000,1,-0.5))
effectiveSize(rAR1(1000,1,-0.9))
setwd("~/GitHub/GNGP_LMC")
read.csv("standard.csv")
read.csv("standard.csv",header=F)
effectiveSize(stand[,1])
stand = read.csv("standard.csv",header=F)
effectiveSize(stand[,1])
stand = read.csv("standard.csv",header=F)
effectiveSize(stand[,1])
effectiveSize(stand[,2])
effectiveSize(stand[,3])
effectiveSize(stand[,4])
stand = read.csv("standard.csv",header=F)
effectiveSize(stand[,1])
effectiveSize(stand[,2])
effectiveSize(stand[,3])
effectiveSize(stand[,4])
inter = read.csv("interweave.csv",header=F)
effectiveSize(inter[,1])
effectiveSize(inter[,2])
effectiveSize(inter[,3])
effectiveSize(inter[,4])
library(coda)
rAR1 = function(n,sigma,alpha){
eps = rnorm(n,0,sigma)
x = rep(0,n)
x[1] = eps[1]
for (i in 2:n) {
x[i] = alpha*x[i-1] + eps[i]
}
return(x)
}
effectiveSize(1:1000)
effectiveSize(rnorm(1000))
effectiveSize(rAR1(1000,1,0.9))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.1))
effectiveSize(rAR1(1000,1,-0.1))
effectiveSize(rAR1(1000,1,-0.5))
effectiveSize(rAR1(1000,1,-0.9))
centered = read.csv("centered.csv",header=F)
effectiveSize(centered[,1])
effectiveSize(centered[,2])
effectiveSize(centered[,3])
effectiveSize(centered[,4])
white = read.csv("white.csv",header=F)
effectiveSize(white[,1])
effectiveSize(white[,2])
effectiveSize(white[,3])
effectiveSize(white[,4])
interweave = read.csv("interweave.csv",header=F)
effectiveSize(interweave[,1])
effectiveSize(interweave[,2])
effectiveSize(interweave[,3])
effectiveSize(interweave[,4])
library(coda)
rAR1 = function(n,sigma,alpha){
eps = rnorm(n,0,sigma)
x = rep(0,n)
x[1] = eps[1]
for (i in 2:n) {
x[i] = alpha*x[i-1] + eps[i]
}
return(x)
}
effectiveSize(1:1000)
effectiveSize(rnorm(1000))
effectiveSize(rAR1(1000,1,0.9))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.1))
effectiveSize(rAR1(1000,1,-0.1))
effectiveSize(rAR1(1000,1,-0.5))
effectiveSize(rAR1(1000,1,-0.9))
centered = read.csv("centered.csv",header=F)
effectiveSize(centered[,1])
effectiveSize(centered[,2])
effectiveSize(centered[,3])
effectiveSize(centered[,4])
white = read.csv("white.csv",header=F)
effectiveSize(white[,1])
effectiveSize(white[,2])
effectiveSize(white[,3])
effectiveSize(white[,4])
interweave = read.csv("interweave.csv",header=F)
effectiveSize(interweave[,1])
effectiveSize(interweave[,2])
effectiveSize(interweave[,3])
effectiveSize(interweave[,4])
library(coda)
rAR1 = function(n,sigma,alpha){
eps = rnorm(n,0,sigma)
x = rep(0,n)
x[1] = eps[1]
for (i in 2:n) {
x[i] = alpha*x[i-1] + eps[i]
}
return(x)
}
effectiveSize(1:1000)
effectiveSize(rnorm(1000))
effectiveSize(rAR1(1000,1,0.9))
effectiveSize(rAR1(1000,1,0.5))
effectiveSize(rAR1(1000,1,0.1))
effectiveSize(rAR1(1000,1,-0.1))
effectiveSize(rAR1(1000,1,-0.5))
effectiveSize(rAR1(1000,1,-0.9))
centered = read.csv("centered.csv",header=F)
effectiveSize(centered[,1])
effectiveSize(centered[,2])
effectiveSize(centered[,3])
effectiveSize(centered[,4])
white = read.csv("white.csv",header=F)
effectiveSize(white[,1])
effectiveSize(white[,2])
effectiveSize(white[,3])
effectiveSize(white[,4])
interweave = read.csv("interweave.csv",header=F)
effectiveSize(interweave[,1])
effectiveSize(interweave[,2])
effectiveSize(interweave[,3])
effectiveSize(interweave[,4])
