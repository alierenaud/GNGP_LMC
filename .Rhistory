plot(loc_grid,x_grid,type="l")
points(loc_obs[y==1],x_obs[y==1],cex=0.5,pch=17,col="orange")
points(loc_obs[y==0],x_obs[y==0],cex=0.5,pch=15,col="blue")
z = rep(0,n_obs)
for (i in 1:n_obs) {
z[i] = rnorm(1,x_obs[i],1)
}
y = ifelse(z>0,1,0)
plot(loc_obs,y,pch=4)
####
### initial state
x_grid=rnorm(n_grid+1)
x_obs=rnorm(n_obs)
# x_grid=0.1*rnorm(n_grid+1)
# x_obs=2*(y-0.5)
z=y-1/2
thetas_nng = rep(0,N)
wm_vc
wm_vc$B_u_col
wm_vc$B_u_cols
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
require(rSPDE)
require(truncnorm)
### trunc norm sampler
truncNormSampler = function(y,x){
if(y == 1){
rtruncnorm(1, a=0, b=Inf, mean = x, sd = 1)
}else{
rtruncnorm(1, a=-Inf, b=0, mean = x, sd = 1)
}
}
### functions
expCorr = function(dists,theta){
matern.covariance(dists,theta,0.5,1)
}
makeGrid = function(n){
(0:(n-1))/(n-1)
}
weight_var = function(theta,m,n_obs,n_grid,dists,distMat_m,neighbor,antineigbors){
### m+1 x m+1 cov matrix on grid
S = expCorr(distMat_m,theta)
### cond variance on grid
D_s = rep(0,n_grid+1)
D_s[1] = 1
### mean weigths on grid
A_s = matrix(0,m,m)
for (i in 1:m) {
invMat = solve(S[1:i,1:i])
A_s[i,1:i] = S[i+1,1:i] %*% invMat
D_s[i+1] = S[i+1,i+1] - A_s[i,1:i]%*% S[1:i,i+1]
}
D_s[(m+2):(n_grid+1)] = D_s[m+1]
### cond variance of observations
F_u = rep(0,n_obs)
### mean weights of observations
B_u = matrix(0,n_obs,m)
for (i in 1:n_obs) {
vecs = expCorr(dists[i,],theta)
B_u[i,] = t(vecs) %*% invMat
F_u[i] = 1 - B_u[i,]%*% vecs
}
### columns of B_u
B_u_cols = list()
for (i in 1:(n_grid+1)) {
antineigh = antineigbors[[i]]
n_anti = length(antineigh)
vec_weights = rep(0,n_anti)
for (j in 1:n_anti) {
this_antineigh = antineigh[j]
vec_weights[j] = B_u[this_antineigh,which(neighbor[this_antineigh,]==i)]
}
B_u_cols[[i]] = vec_weights
}
### cols of A_s-I
C_s_col = list()
##### 1st col
this_vec = rep(0,m+1)
this_vec[1] = 1
this_vec[2:(m+1)] = -A_s[,1]
C_s_col[[1]] = this_vec
##### 2 to m-1
for (i in 2:(m-1)) {
this_vec[2:(m+2-i)] = -A_s[i:m,i]
this_vec[(m+2-i):m+1] = -A_s[m,(i-1):1]
C_s_col[[i]] = this_vec
}
##### m to n_grid + 1 - m
for (i in m:(n_grid + 1 - m)) {
this_vec[2:(m+1)] = -A_s[m,m:1]
C_s_col[[i]] = this_vec
}
##### m to n_grid + 2 - m to n_grid
for (i in (n_grid + 2 - m):(n_grid)) {
this_vec = c(1,-A_s[m,m:(2+i-(n_grid+2-m))])
# this_vec[(n_grid+3-i):(m+1)] = 0
C_s_col[[i]] = this_vec
}
##### n_grid+1
# this_vec[2:(m+1)] = 0
C_s_col[[n_grid+1]] = c(1)
return(list(A_s = A_s,D_s = D_s, B_u = B_u, F_u = F_u, B_u_cols = B_u_cols, C_s_col=C_s_col))
}
N = 10000
theta  = 10
m = 10
n_obs = 1000
n_grid = 200
a = 3
b = 30
loc_obs = runif(n_obs)
loc_grid = makeGrid(n_grid+1)
neigbors = matrix(0,n_obs,m)
dists = matrix(0,n_obs,m)
dists_m = matrix(0,m+1,m+1)
### computing distances and neighbors
for (i in 1:(m+1)) {
for (j in 1:(m+1)) {
dists_m[i,j] = abs(i-j)/n_grid
}
}
for (i in 1:n_obs) {
left_neigh = ceiling(loc_obs[i]*n_grid)
if(left_neigh < m/2){
neigbors[i,] = 1:m
}else if(left_neigh > n_grid-m/2+1){
neigbors[i,] = (n_grid-m+2):(n_grid+1)
}else{
neigbors[i,] = (left_neigh - m/2 + 1):  (left_neigh + m/2)
}
}
for (i in 1:n_obs) {
dists[i,] = abs(loc_grid[neigbors[i,]] - loc_obs[i])
}
antineigbors = list()
for(i in 1:m){
antineigbors[[i]] = which(loc_obs < loc_grid[i] + m/2/n_grid)
}
for(i in (m+1):(n_grid+1-m)){
antineigbors[[i]] = which(loc_obs > loc_grid[i] - m/2/n_grid & loc_obs < loc_grid[i] + m/2/n_grid)
}
for(i in (n_grid+2-m):(n_grid+1)){
antineigbors[[i]] = which(loc_obs > loc_grid[i] - m/2/n_grid)
}
wm_vc = weight_var(theta,m,n_obs,n_grid,dists,dists_m,neigbors,antineigbors)
##### Generating random field
dists_all = as.matrix(dist(c(loc_obs,loc_grid),diag=TRUE))
Sigma = expCorr(dists_all,theta)
x = t(chol(Sigma))%*%rnorm(n_obs+n_grid+1)
x_obs = x[1:n_obs]
x_grid = x[(n_obs+1):(n_obs+n_grid+1)]
x_grid_true = x_grid
x_obs_true = x_obs
plot(loc_grid,x_grid,type="l")
# points(loc_obs[y==1],x_obs[y==1],cex=0.5,pch=17,col="orange")
# points(loc_obs[y==0],x_obs[y==0],cex=0.5,pch=15,col="blue")
z = rep(0,n_obs)
for (i in 1:n_obs) {
z[i] = rnorm(1,x_obs[i],1)
}
y = ifelse(z>0,1,0)
plot(loc_obs,y,pch=4)
####
### initial state
x_grid=rnorm(n_grid+1)
x_obs=rnorm(n_obs)
# x_grid=0.1*rnorm(n_grid+1)
# x_obs=2*(y-0.5)
z=y-1/2
thetas_nng = rep(0,N)
wm_vc$B_u_cols
wm_vc$B_u_col
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
require(rSPDE)
require(truncnorm)
### trunc norm sampler
truncNormSampler = function(y,x){
if(y == 1){
rtruncnorm(1, a=0, b=Inf, mean = x, sd = 1)
}else{
rtruncnorm(1, a=-Inf, b=0, mean = x, sd = 1)
}
}
### functions
expCorr = function(dists,theta){
matern.covariance(dists,theta,0.5,1)
}
makeGrid = function(n){
(0:(n-1))/(n-1)
}
weight_var = function(theta,m,n_obs,n_grid,dists,distMat_m,neighbor,antineigbors){
### m+1 x m+1 cov matrix on grid
S = expCorr(distMat_m,theta)
### cond variance on grid
D_s = rep(0,n_grid+1)
D_s[1] = 1
### mean weigths on grid
A_s = matrix(0,m,m)
for (i in 1:m) {
invMat = solve(S[1:i,1:i])
A_s[i,1:i] = S[i+1,1:i] %*% invMat
D_s[i+1] = S[i+1,i+1] - A_s[i,1:i]%*% S[1:i,i+1]
}
D_s[(m+2):(n_grid+1)] = D_s[m+1]
### cond variance of observations
F_u = rep(0,n_obs)
### mean weights of observations
B_u = matrix(0,n_obs,m)
for (i in 1:n_obs) {
vecs = expCorr(dists[i,],theta)
B_u[i,] = t(vecs) %*% invMat
F_u[i] = 1 - B_u[i,]%*% vecs
}
### columns of B_u
B_u_cols = list()
for (i in 1:(n_grid+1)) {
antineigh = antineigbors[[i]]
n_anti = length(antineigh)
vec_weights = rep(0,n_anti)
for (j in 1:n_anti) {
this_antineigh = antineigh[j]
vec_weights[j] = B_u[this_antineigh,which(neighbor[this_antineigh,]==i)]
}
B_u_cols[[i]] = vec_weights
}
### cols of A_s-I
C_s_col = list()
##### 1st col
this_vec = rep(0,m+1)
this_vec[1] = 1
this_vec[2:(m+1)] = -A_s[,1]
C_s_col[[1]] = this_vec
##### 2 to m-1
for (i in 2:(m-1)) {
this_vec[2:(m+2-i)] = -A_s[i:m,i]
this_vec[(m+2-i):m+1] = -A_s[m,(i-1):1]
C_s_col[[i]] = this_vec
}
##### m to n_grid + 1 - m
for (i in m:(n_grid + 1 - m)) {
this_vec[2:(m+1)] = -A_s[m,m:1]
C_s_col[[i]] = this_vec
}
##### m to n_grid + 2 - m to n_grid
for (i in (n_grid + 2 - m):(n_grid)) {
this_vec = c(1,-A_s[m,m:(2+i-(n_grid+2-m))])
# this_vec[(n_grid+3-i):(m+1)] = 0
C_s_col[[i]] = this_vec
}
##### n_grid+1
# this_vec[2:(m+1)] = 0
C_s_col[[n_grid+1]] = c(1)
return(list(A_s = A_s,D_s = D_s, B_u = B_u, F_u = F_u, B_u_cols = B_u_cols, C_s_col=C_s_col))
}
N = 10000
theta  = 10
m = 10
n_obs = 1000
n_grid = 200
a = 3
b = 30
loc_obs = runif(n_obs)
loc_grid = makeGrid(n_grid+1)
neigbors = matrix(0,n_obs,m)
dists = matrix(0,n_obs,m)
dists_m = matrix(0,m+1,m+1)
### computing distances and neighbors
for (i in 1:(m+1)) {
for (j in 1:(m+1)) {
dists_m[i,j] = abs(i-j)/n_grid
}
}
for (i in 1:n_obs) {
left_neigh = ceiling(loc_obs[i]*n_grid)
if(left_neigh < m/2){
neigbors[i,] = 1:m
}else if(left_neigh > n_grid-m/2+1){
neigbors[i,] = (n_grid-m+2):(n_grid+1)
}else{
neigbors[i,] = (left_neigh - m/2 + 1):  (left_neigh + m/2)
}
}
for (i in 1:n_obs) {
dists[i,] = abs(loc_grid[neigbors[i,]] - loc_obs[i])
}
antineigbors = list()
for(i in 1:m){
antineigbors[[i]] = which(loc_obs < loc_grid[i] + m/2/n_grid)
}
for(i in (m+1):(n_grid+1-m)){
antineigbors[[i]] = which(loc_obs > loc_grid[i] - m/2/n_grid & loc_obs < loc_grid[i] + m/2/n_grid)
}
for(i in (n_grid+2-m):(n_grid+1)){
antineigbors[[i]] = which(loc_obs > loc_grid[i] - m/2/n_grid)
}
wm_vc = weight_var(theta,m,n_obs,n_grid,dists,dists_m,neigbors,antineigbors)
wm_vc
##### Generating random field
dists_all = as.matrix(dist(c(loc_obs,loc_grid),diag=TRUE))
Sigma = expCorr(dists_all,theta)
x = t(chol(Sigma))%*%rnorm(n_obs+n_grid+1)
x_obs = x[1:n_obs]
x_grid = x[(n_obs+1):(n_obs+n_grid+1)]
x_grid_true = x_grid
x_obs_true = x_obs
plot(loc_grid,x_grid,type="l")
# points(loc_obs[y==1],x_obs[y==1],cex=0.5,pch=17,col="orange")
# points(loc_obs[y==0],x_obs[y==0],cex=0.5,pch=15,col="blue")
z = rep(0,n_obs)
for (i in 1:n_obs) {
z[i] = rnorm(1,x_obs[i],1)
}
y = ifelse(z>0,1,0)
plot(loc_obs,y,pch=4)
####
### initial state
x_grid=rnorm(n_grid+1)
x_obs=rnorm(n_obs)
# x_grid=0.1*rnorm(n_grid+1)
# x_obs=2*(y-0.5)
z=y-1/2
thetas_nng = rep(0,N)
wm_vc$B_u_col
wm_vc$B_u_cols
wm_vc$B_u_co
wm_vc$B_u
wm_vc$B_u_c
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
m.r.xy$p.theta.samples
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
plot(m.r.xy$p.beta.samples)
plot(m.r.xy$p.theta.samples[,1])
plot(m.r.xy$p.theta.samples[,2])
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
plot(m.r.xy$p.beta.samples)
plot(m.r.xy$p.theta.samples[,1])
plot(m.r.xy$p.theta.samples[,2])
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
plot(m.r.xy$p.beta.samples)
plot(m.r.xy$p.theta.samples[,1])
plot(m.r.xy$p.theta.samples[,2])
source("~/Dropbox/R_scripts_GP/exp_spnngp.R")
plot(m.r.xy$p.beta.samples)
plot(m.r.xy$p.theta.samples[,1])
plot(m.r.xy$p.theta.samples[,2])
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
wm_vc
wm_vc$A_u
wm_vc$A_s
wm_vc$C_s_col
wm_vc$D_s
F_u
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
print("time gngp: ")
print(tnng)
print("acc theta: ")
print(mean(acc_t))
plot(thetas_nng,type='l')
thetas_nng
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
debugSource("~/Dropbox/R_scripts_GP/gngp_1D.R")
debugSource("~/Dropbox/R_scripts_GP/gngp_1D.R")
theta + eps*rnorm(1)
theta_prime > a & theta_prime < b
theta_prime = theta + eps*rnorm(1)
theta_prime > a & theta_prime < b
theta_prime
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
debugSource("~/Dropbox/R_scripts_GP/gngp_1D.R")
A_s[j-1,]
source("~/Dropbox/R_scripts_GP/gngp_1D.R")
lambda = 100
N = rpois(lambda)
lambda = 100
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
locs
lambda = 100
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
D = dist(locs)
D
lambda = 100
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
D = as.matrix(dist(locs), diag = TRUE)
D
D
lambda = 100
N = rpois(1,lambda)
locs = matrix(runif(2*N),N,2)
D = as.matrix(dist(locs), diag = TRUE)
D
lambda = 100
N = rpois(1,lambda)
X = matrix(runif(2*N),N,2)
D = as.matrix(dist(locs), diag = TRUE)
theta = 0.5
Sigma = exp(-theta*D)
beta = chol(Sigma)%*%rnorm(N)
lambda = 100
N = rpois(1,lambda)
X = matrix(runif(2*N),N,2)
D = as.matrix(dist(locs), diag = TRUE)
theta = 0.5
Sigma = exp(-theta*D)
beta = chol(Sigma)%*%t(rnorm(N))
lambda = 100
N = rpois(1,lambda)
X = matrix(runif(2*N),N,2)
D = as.matrix(dist(locs), diag = TRUE)
theta = 0.5
Sigma = exp(-theta*D)
beta = chol(Sigma)%*%rnorm(N)
chol(Sigma)
N
lambda = 100
N = rpois(1,lambda)
X = matrix(runif(2*N),N,2)
D = as.matrix(dist(X), diag = TRUE)
theta = 0.5
Sigma = exp(-theta*D)
beta = chol(Sigma)%*%rnorm(N)
lambda = 100
N = rpois(1,lambda)
X = matrix(runif(2*N),N,2)
D = as.matrix(dist(X), diag = TRUE)
theta = 0.5
Sigma = exp(-theta*D)
beta = chol(Sigma)%*%rnorm(N)
pnorm(beta)
lambda = 100
N = rpois(1,lambda)
X = matrix(runif(2*N),N,2)
D = as.matrix(dist(X), diag = TRUE)
theta = 0.5
Sigma = exp(-theta*D)
beta = chol(Sigma)%*%rnorm(N)
proba = pnorm(beta)
lambda = 100
N = rpois(1,lambda)
X = matrix(runif(2*N),N,2)
D = as.matrix(dist(X), diag = TRUE)
theta = 0.5
Sigma = exp(-theta*D)
beta = chol(Sigma)%*%rnorm(N)
probs = pnorm(beta)
lambda = 100
N = rpois(1,lambda)
X = matrix(runif(2*N),N,2)
D = as.matrix(dist(X), diag = TRUE)
theta = 0.5
Sigma = exp(-theta*D)
beta = chol(Sigma)%*%rnorm(N)
probs = pnorm(beta)
obs = rbinom(1,1,probs)
obs
25*24/2
5*4
5*4/2
log(3)
log(30)
log(-3)
log(3)
1/log(3)
1/log(30)
log(0.1)
log(1)
log(3)
log(30)
log(5)
log(25)
seq(log(5),log(25),length.out = 5)
elb = function(n){
(n-3/4)^(1/2) - 1/2
}
elb(3)
elb = function(n){
(n-3/4)^(1/2) - 1/2
}
elb(4)
(10-1/2)^2+3/4
elb(5)
elb(6)
24.13*24
setwd("~/Documents/GitHub/GNGP_LMC")
require(tidyverse)
dMSE = read.csv("dMSE_nn.csv",header=F)
dMSE = t(dMSE)
colnames(dMSE) = c("Triangular", "Full", "Block Diagonal", "Diagonal")
dMSE = pivot_longer(as.data.frame(dMSE),c(1,2,3,4),names_to = "model")
p <- ggplot(dMSE, aes(x=model, y=value, fill=model)) +
geom_boxplot() + ylab("MSE Difference") + xlab("") + guides(fill="none")  +
theme_bw() + theme(axis.title.x=element_blank()) #+ facet_wrap(scale ~ parameter,scales="free_y", nrow=3)
ggsave(
"MSEdiff_nn.pdf",
plot = p,
device = "pdf", width = 6, height=3
)
